on skript start:
	reset()

on first join:
	wait 2 tick
	set gamemode of player to adventure
	#ステータス設定
	command "/status_reset %player%"
	wait 1 tick
	set gamemode of player to adventure

command /status_reset <player>:
	permission: siso
	trigger:
		set {xp.%arg 1%} to 0
		set {first_join.%arg 1%} to floor(unix timestamp of now)
		set {kill.%arg 1%} to 0
		delete {has_kits.%arg 1%::*}
		add "attacker" to {has_kits.%arg 1%::*}
		add "builder" to {has_kits.%arg 1%::*}
		add "miner" to {has_kits.%arg 1%::*}

function bossbar_timer(seconds: number):
	set {bartimer} to new bossbar
	set color of bossbar {bartimer} to purple
	set style of bossbar {bartimer} to solid
	set skellett progress of bossbar {bartimer} to 1
	set {_time} to {_seconds}
	set {_division} to {_seconds}
	loop all players:
		add loop-player to boss bar {bartimer}
	while {_time} > 0:
		if {game} is not true:
			loop all players:
				try:
					remove loop-player from bossbar {bartimer}
			exit loop
			stop
		if {_time} >= 60:
			if mod({_time}, 60) >= 10:
				set string of bossbar {bartimer} to "&6&lTime &r&l%floor({_time} / 60)%:%mod({_time}, 60)%"
			else:
				set string of bossbar {bartimer} to "&6&lTime &r&l%floor({_time} / 60)%:0%mod({_time}, 60)%"
		else if {_time} >= 10:
			set string of bossbar {bartimer} to "&6&lTime &r&l0:%{_time}%"
		else:
			set string of bossbar {bartimer} to "&6&lTime &r&l0:0%{_time}%"
			send title "&e&l%{_time}%" to all players for 1 second
		remove 1 from {_time}
		wait 1 seconds
	loop all players:
		try:
			remove loop-player from bossbar {bartimer}
	delete {bartimer}
	#タイムアップだったら
	if {game} is true:
		timeup()

function auto_team_select() :: string:
	set {_reds} to number of {red::*}
	set {_blues} to number of {blue::*}
	if {red::*} is not set:
		set {_reds} to 0
	if {blue::*} is not set:
		set {_blues} to 0
	if {_reds} = {_blues}:
		set {_randomjoin} to random integer between 1 and 2
		if {_randomjoin} is 1:
			return "red"
		else if {_randomjoin} is 2:
			return "blue"
	else if {_reds} < {_blues}:
		return "red"
	else if {_reds} > {_blues}:
		return "blue"

#function client_side_equip(entity: entity, itemslot: string, item: item, players: players):
#	replace " " with "" in {_itemslot}
#	set {_} to new play_server_entity_equipment packet
#	set int pnum 0 of {_} to id of {_entity}
#	set "ItemSlot" penum 0 of {_} to {_itemslot}
#	set "ItemModifier" pinfo 0 of {_} to {_item}
#	send {_players::*} packet {_}
#
#function client_side_helmet_equip(p: player):
#	if {red::*} contain {_p}:
#		set {_helmet} to leather helmet
#		dye {_helmet} red
#	if {blue::*} contain {_p}:
#		set {_helmet} to leather helmet
#		dye {_helmet} blue

on death of player:
	wait 2 ticks
	force player to respawn

on break of emerald block:
	{game} is true
	cancel event

on mine:
	block is iron ore or gold ore
	if block is iron ore:
		cancel event
		give iron ingot to player
	if block is gold ore:
		cancel event
		give gold ingot to player
	set {_loc} to location of block
	set {_block} to type of block
	set block at {_loc} to bedrock
	wait 3 seconds
	set block at {_loc} to {_block}
			
on inventory click:
	#39 is helmet
	if clicked slot is 39:
		if clicked item is leather helmet:
			cancel event

on rightclick on villager:
	if clicked entity is villager:
		if name of clicked entity contain "SHOP":
			cancel event
			execute player command "/show_shop %player%"

on damage of villager:
	{game} is true
	cancel event

on food level change:
	cancel event

on command "/kill":
	player is not op
	cancel event
	kill player

function sound(p: player, sound: text, pitch: number = 1):
	play sound {_sound} with volume 1 and pitch {_pitch} at {_p} for {_p}

function proper_case(string: text) :: text:
	set {_first_text} to first characters of {_string} in upper case
	set {_split_first_text} to last length of {_string} - 1 characters of {_string}
	return "%{_first_text}%%{_split_first_text}%"

function rank_tool(tool: item type) :: number:
	if "%{_tool}%" contain "wooden":
		return 1
	if "%{_tool}%" contain "gold":
		return 2
	if "%{_tool}%" contain "stone":
		return 3
	if "%{_tool}%" contain "iron":
		return 4
	if "%{_tool}%" contain "diamond":
		return 5
	
	#Armor

	if "%{_tool}%" contain "leather":
		return 1
	if "%{_tool}%" contain "gold":
		return 2
	if "%{_tool}%" contain "chainmail":
		return 3
	if "%{_tool}%" contain "iron":
		return 4
	if "%{_tool}%" contain "diamond":
		return 5
	

function has_higher_tool(p: player, item: item) :: item type:
	if {_item} is sword:
		set {_type} to sword

	if {_item} is armor:
		if {_item} is helmet:
			set {_type} to helmet
		if {_item} is chestplate:
			set {_type} to chestplate
		if {_item} is leggings:
			set {_type} to leggings
		if {_item} is boots:
			set {_type} to boots

	if {_item} is pickaxe:
		set {_type} to pickaxe

	if {_item} is axe:
		set {_type} to axe

	if {_item} is shovel:
		set {_type} to shovel

	loop all items in {_p}'s inventory:
		if type of loop-item is {_type}:
			if {_most_higher_rank} is not set:
				set {_most_higher_rank} to rank_tool(type of loop-item)
				set {_most_higher_item} to type of loop-item
			else:
				set {_rank_tool} to rank_tool(type of loop-item)
				if {_most_higher_rank} < {_rank_tool}:
					set {_most_higher_rank} to {_rank_tool}
					set {_most_higher_item} to type of loop-item
	return {_most_higher_item}

function replace_tool(p: player, item: item):
	set {_replace_item} to has_higher_tool({_p}, {_item})
	loop 40 times:
		if type of slot loop-number - 1 of {_p}'s inventory is {_replace_item}:
			set slot loop-number - 1 of {_p}'s inventory to {_item}
